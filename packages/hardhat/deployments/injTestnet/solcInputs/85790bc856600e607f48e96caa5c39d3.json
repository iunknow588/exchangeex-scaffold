{
  "language": "Solidity",
  "sources": {
    "contracts/ExchangeEx_Standalone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// ============================================================================\n// 独立版本的 ExchangeEx.sol - 包含所有必要依赖\n// 可以直接复制到其他项目中使用\n// ============================================================================\n\n// ============================================================================\n// CosmosTypes.sol - Cosmos 类型定义\n// ============================================================================\nlibrary Cosmos {\n    struct Coin {\n        uint256 amount;\n        string denom;\n    }\n}\n\n// ============================================================================\n// ExchangeTypes.sol - Exchange 类型定义\n// ============================================================================\nlibrary ExchangeTypes {\n    /// @dev User-defined type for exchange methods that can be approved. This \n    /// matches the MsgType type defined in the Exchange authz types.\n    type MsgType is uint8;\n\n    /// @dev Define all the exchange methods available for approval.\n    MsgType public constant MsgType_Deposit = MsgType.wrap(1);\n    MsgType public constant MsgType_Withdraw = MsgType.wrap(2);\n    MsgType public constant MsgType_SubaccountTransfer = MsgType.wrap(3);\n    MsgType public constant MsgType_ExternalTransfer = MsgType.wrap(4);\n    MsgType public constant MsgType_IncreasePositionMargin = MsgType.wrap(5);\n    MsgType public constant MsgType_DecreasePositionMargin = MsgType.wrap(6);\n    MsgType public constant MsgType_BatchUpdateOrders = MsgType.wrap(7);\n    MsgType public constant MsgType_CreateDerivativeLimitOrder = MsgType.wrap(8);\n    MsgType public constant MsgType_BatchCreateDerivativeLimitOrders = MsgType.wrap(9);\n    MsgType public constant MsgType_CreateDerivativeMarketOrder = MsgType.wrap(10);\n    MsgType public constant MsgType_CancelDerivativeOrder = MsgType.wrap(11);\n    MsgType public constant MsgType_BatchCancelDerivativeOrders = MsgType.wrap(12);\n    MsgType public constant MsgType_CreateSpotLimitOrder = MsgType.wrap(13);\n    MsgType public constant MsgType_BatchCreateSpotLimitOrders = MsgType.wrap(14);\n    MsgType public constant MsgType_CreateSpotMarketOrder = MsgType.wrap(15);\n    MsgType public constant MsgType_CancelSpotOrder = MsgType.wrap(16);\n    MsgType public constant MsgType_BatchCancelSpotOrders = MsgType.wrap(17);\n    MsgType public constant MsgType_Unknown = MsgType.wrap(18);\n}\n\n// ============================================================================\n// Exchange.sol - Exchange 预编译合约接口\n// ============================================================================\ninterface IExchangeModule {\n    // ========================================================================\n    // AUTHZ\n    // ========================================================================\n    struct Authorization {\n        ExchangeTypes.MsgType method;\n        Cosmos.Coin[] spendLimit;\n        uint256 duration;\n    }\n\n    function approve(\n        address grantee,\n        Authorization[] calldata authorizations\n    ) external returns (bool approved);\n\n    function revoke(\n        address grantee,\n        ExchangeTypes.MsgType[] calldata methods\n    ) external returns (bool revoked);\n\n    function allowance(\n        address grantee,\n        address granter,\n        ExchangeTypes.MsgType method\n    ) external view returns (bool allowed);\n\n    // ========================================================================\n    // ACCOUNT QUERIES\n    // ========================================================================\n    function subaccountDeposit(\n        string calldata subaccountID,\n        string calldata denom\n    ) external view returns (uint256 availableBalance, uint256 totalBalance);\n\n    function subaccountDeposits(\n        string calldata subaccountID,\n        string calldata trader,\n        uint32 subaccountNonce\n    ) external view returns (SubaccountDepositData[] calldata deposits);\n\n    struct SubaccountDepositData {\n        string denom;\n        uint256 availableBalance;\n        uint256 totalBalance;\n    }\n\n    function subaccountPositions(\n        string calldata subaccountID\n    ) external view returns (DerivativePosition[] calldata positions);\n\n    struct DerivativePosition {\n        string subaccountID;\n        string marketID;\n        bool isLong;\n        uint256 quantity;\n        uint256 entryPrice;\n        uint256 margin;\n        uint256 cumulativeFundingEntry;\n    }\n\n    // ========================================================================\n    // ACCOUNT TRANSACTIONS\n    // ========================================================================\n    function deposit(\n        address sender,\n        string calldata subaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external returns (bool success);\n\n    function withdraw(\n        address sender,\n        string calldata subaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external returns (bool success);\n\n    function subaccountTransfer(\n        address sender,\n        string calldata sourceSubaccountID,\n        string calldata destinationSubaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external returns (bool success);\n\n    function externalTransfer(\n        address sender,\n        string calldata sourceSubaccountID,\n        string calldata destinationSubaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external returns (bool success);\n\n    // ========================================================================\n    // DERIVATIVE MARKETS TRANSACTIONS\n    // ========================================================================\n    struct DerivativeOrder {\n        string marketID;\n        string subaccountID;\n        string feeRecipient;\n        uint256 price;\n        uint256 quantity;\n        string cid;\n        string orderType;\n        uint256 margin;\n        uint256 triggerPrice;\n    }\n\n    struct CreateDerivativeLimitOrderResponse {\n        string orderHash;\n        string cid;\n    }\n\n    function createDerivativeLimitOrder(\n        address sender,\n        DerivativeOrder calldata order\n    ) external returns (CreateDerivativeLimitOrderResponse calldata response);\n\n    // ========================================================================\n    // SPOT MARKETS TRANSACTIONS\n    // ========================================================================\n    struct SpotOrder {\n        string marketID;\n        string subaccountID;\n        string feeRecipient;\n        uint256 price;\n        uint256 quantity;\n        string cid;\n        string orderType;\n        uint256 triggerPrice;\n    }\n\n    struct CreateSpotLimitOrderResponse {\n        string orderHash;\n        string cid;\n    }\n\n    struct CreateSpotMarketOrderResponse {\n        string orderHash;\n        string cid;\n        uint256 quantity;\n        uint256 price;\n        uint256 fee;\n    }\n\n    struct BatchCreateSpotLimitOrdersResponse {\n        string[] orderHashes;\n        string[] createdOrdersCids;\n        string[] failedOrdersCids;\n    }\n\n    struct OrderData {\n        string marketID;\n        string subaccountID;\n        string orderHash;\n        int32 orderMask;\n        string cid;\n    }\n\n    function createSpotLimitOrder(\n        address sender,\n        SpotOrder calldata order\n    ) external returns (CreateSpotLimitOrderResponse calldata response);\n\n    function createSpotMarketOrder(\n        address sender,\n        SpotOrder calldata order\n    ) external returns (CreateSpotMarketOrderResponse calldata response);\n\n    function cancelSpotOrder(\n        address sender,\n        string calldata marketID,\n        string calldata subaccountID,\n        string calldata orderHash,\n        string calldata cid\n    ) external returns (bool success);\n\n    function batchCreateSpotLimitOrders(\n        address sender,\n        SpotOrder[] calldata orders\n    ) external returns (BatchCreateSpotLimitOrdersResponse calldata response);\n\n    function batchCancelSpotOrders(\n        address sender,\n        OrderData[] calldata orderData\n    ) external returns (bool[] calldata success);\n\n    // ========================================================================\n    // SPOT MARKETS QUERIES\n    // ========================================================================\n    struct SpotOrdersRequest {\n        string marketID;\n        string subaccountID;\n        string[] orderHashes;\n    }\n\n    struct TrimmedSpotLimitOrder {\n        uint256 price;\n        uint256 quantity;\n        uint256 fillable;\n        bool isBuy;\n        string orderHash;\n        string cid;\n    }\n\n    function spotOrdersByHashes(\n        SpotOrdersRequest calldata request\n    ) external returns (TrimmedSpotLimitOrder[] calldata orders);\n}\n\n// ============================================================================\n// ExchangeEx.sol - 主要合约\n// ============================================================================\ncontract ExchangeEx {\n    address constant exchangeContract = 0x0000000000000000000000000000000000000065;\n    IExchangeModule exchange = IExchangeModule(exchangeContract);\n\n    // 权限控制\n    mapping(address => bool) public authorizedTraders;\n    address public owner;\n\n    // 事件定义\n    event SpotOrderCreated(string marketID, string orderHash, string cid, string orderType);\n    event SpotOrderCancelled(string marketID, string orderHash, bool success);\n    event DerivativeOrderCreated(string marketID, string orderHash, string cid);\n    event TraderAuthorized(address trader);\n    event TraderRevoked(address trader);\n\n    constructor() {\n        owner = msg.sender;\n        authorizedTraders[msg.sender] = true;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(authorizedTraders[msg.sender], \"Not authorized trader\");\n        _;\n    }\n\n    // ========================================================================\n    // 权限管理\n    // ========================================================================\n    function authorizeTrader(address trader) external onlyOwner {\n        authorizedTraders[trader] = true;\n        emit TraderAuthorized(trader);\n    }\n\n    function revokeTrader(address trader) external onlyOwner {\n        authorizedTraders[trader] = false;\n        emit TraderRevoked(trader);\n    }\n\n    // ========================================================================\n    // 基础功能\n    // ========================================================================\n    function deposit(\n        string calldata subaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external onlyAuthorized returns (bool) {\n        try exchange.deposit(address(this), subaccountID, denom, amount) returns (bool success) {\n            return success;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"Deposit error: \", reason)));\n        } catch {\n            revert(\"Unknown error during deposit\");\n        }\n    }\n\n    function withdraw(\n        string calldata subaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external onlyAuthorized returns (bool) {\n        try exchange.withdraw(address(this), subaccountID, denom, amount) returns (bool success) {\n            return success;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"Withdraw error: \", reason)));\n        } catch {\n            revert(\"Unknown error during withdraw\");\n        }\n    }\n\n    function subaccountPositions(\n        string calldata subaccountID\n    ) external view returns (IExchangeModule.DerivativePosition[] memory positions) {\n        return exchange.subaccountPositions(subaccountID);\n    }\n\n    function createDerivativeLimitOrder(\n        IExchangeModule.DerivativeOrder calldata order\n    ) external onlyAuthorized returns (IExchangeModule.CreateDerivativeLimitOrderResponse memory response) {\n        try exchange.createDerivativeLimitOrder(address(this), order) returns (IExchangeModule.CreateDerivativeLimitOrderResponse memory resp) {\n            emit DerivativeOrderCreated(order.marketID, resp.orderHash, resp.cid);\n            return resp;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"CreateDerivativeLimitOrder error: \", reason)));\n        } catch {\n            revert(\"Unknown error during createDerivativeLimitOrder\");\n        }\n    }\n\n    // ========================================================================\n    // 现货市场功能\n    // ========================================================================\n    function createSpotLimitOrder(\n        IExchangeModule.SpotOrder calldata order\n    ) external onlyAuthorized returns (IExchangeModule.CreateSpotLimitOrderResponse memory response) {\n        try exchange.createSpotLimitOrder(address(this), order) returns (IExchangeModule.CreateSpotLimitOrderResponse memory resp) {\n            emit SpotOrderCreated(order.marketID, resp.orderHash, resp.cid, order.orderType);\n            return resp;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"CreateSpotLimitOrder error: \", reason)));\n        } catch {\n            revert(\"Unknown error during createSpotLimitOrder\");\n        }\n    }\n\n    function createSpotMarketOrder(\n        IExchangeModule.SpotOrder calldata order\n    ) external onlyAuthorized returns (IExchangeModule.CreateSpotMarketOrderResponse memory response) {\n        try exchange.createSpotMarketOrder(address(this), order) returns (IExchangeModule.CreateSpotMarketOrderResponse memory resp) {\n            emit SpotOrderCreated(order.marketID, resp.orderHash, resp.cid, order.orderType);\n            return resp;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"CreateSpotMarketOrder error: \", reason)));\n        } catch {\n            revert(\"Unknown error during createSpotMarketOrder\");\n        }\n    }\n\n    function cancelSpotOrder(\n        string calldata marketID,\n        string calldata subaccountID,\n        string calldata orderHash,\n        string calldata cid\n    ) external onlyAuthorized returns (bool success) {\n        try exchange.cancelSpotOrder(address(this), marketID, subaccountID, orderHash, cid) returns (bool result) {\n            emit SpotOrderCancelled(marketID, orderHash, result);\n            return result;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"CancelSpotOrder error: \", reason)));\n        } catch {\n            revert(\"Unknown error during cancelSpotOrder\");\n        }\n    }\n\n    function getSpotOrders(\n        string calldata marketID,\n        string calldata subaccountID,\n        string[] calldata orderHashes\n    ) external returns (IExchangeModule.TrimmedSpotLimitOrder[] memory orders) {\n        IExchangeModule.SpotOrdersRequest memory request = IExchangeModule.SpotOrdersRequest({\n            marketID: marketID,\n            subaccountID: subaccountID,\n            orderHashes: orderHashes\n        });\n        return exchange.spotOrdersByHashes(request);\n    }\n\n    function batchCreateSpotLimitOrders(\n        IExchangeModule.SpotOrder[] calldata orders\n    ) external onlyAuthorized returns (IExchangeModule.BatchCreateSpotLimitOrdersResponse memory response) {\n        try exchange.batchCreateSpotLimitOrders(address(this), orders) returns (IExchangeModule.BatchCreateSpotLimitOrdersResponse memory resp) {\n            for (uint i = 0; i < resp.orderHashes.length; i++) {\n                emit SpotOrderCreated(orders[i].marketID, resp.orderHashes[i], resp.createdOrdersCids[i], orders[i].orderType);\n            }\n            return resp;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"BatchCreateSpotLimitOrders error: \", reason)));\n        } catch {\n            revert(\"Unknown error during batchCreateSpotLimitOrders\");\n        }\n    }\n\n    function batchCancelSpotOrders(\n        IExchangeModule.OrderData[] calldata orderData\n    ) external onlyAuthorized returns (bool[] memory success) {\n        try exchange.batchCancelSpotOrders(address(this), orderData) returns (bool[] memory results) {\n            for (uint i = 0; i < orderData.length; i++) {\n                emit SpotOrderCancelled(orderData[i].marketID, orderData[i].orderHash, results[i]);\n            }\n            return results;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"BatchCancelSpotOrders error: \", reason)));\n        } catch {\n            revert(\"Unknown error during batchCancelSpotOrders\");\n        }\n    }\n\n    // ========================================================================\n    // 便捷功能\n    // ========================================================================\n    function createSpotBuyOrder(\n        string calldata marketID,\n        string calldata subaccountID,\n        uint256 price,\n        uint256 quantity,\n        string calldata cid\n    ) external onlyAuthorized returns (IExchangeModule.CreateSpotLimitOrderResponse memory response) {\n        IExchangeModule.SpotOrder memory order = IExchangeModule.SpotOrder({\n            marketID: marketID,\n            subaccountID: subaccountID,\n            feeRecipient: toAsciiString(address(this)),\n            price: price,\n            quantity: quantity,\n            cid: cid,\n            orderType: \"buy\",\n            triggerPrice: 0\n        });\n        return this.createSpotLimitOrder(order);\n    }\n\n    function createSpotSellOrder(\n        string calldata marketID,\n        string calldata subaccountID,\n        uint256 price,\n        uint256 quantity,\n        string calldata cid\n    ) external onlyAuthorized returns (IExchangeModule.CreateSpotLimitOrderResponse memory response) {\n        IExchangeModule.SpotOrder memory order = IExchangeModule.SpotOrder({\n            marketID: marketID,\n            subaccountID: subaccountID,\n            feeRecipient: toAsciiString(address(this)),\n            price: price,\n            quantity: quantity,\n            cid: cid,\n            orderType: \"sell\",\n            triggerPrice: 0\n        });\n        return this.createSpotLimitOrder(order);\n    }\n\n    function createSpotMarketBuyOrder(\n        string calldata marketID,\n        string calldata subaccountID,\n        uint256 quantity,\n        string calldata cid\n    ) external onlyAuthorized returns (IExchangeModule.CreateSpotMarketOrderResponse memory response) {\n        IExchangeModule.SpotOrder memory order = IExchangeModule.SpotOrder({\n            marketID: marketID,\n            subaccountID: subaccountID,\n            feeRecipient: toAsciiString(address(this)),\n            price: 0,\n            quantity: quantity,\n            cid: cid,\n            orderType: \"buy\",\n            triggerPrice: 0\n        });\n        return this.createSpotMarketOrder(order);\n    }\n\n    function createSpotMarketSellOrder(\n        string calldata marketID,\n        string calldata subaccountID,\n        uint256 quantity,\n        string calldata cid\n    ) external onlyAuthorized returns (IExchangeModule.CreateSpotMarketOrderResponse memory response) {\n        IExchangeModule.SpotOrder memory order = IExchangeModule.SpotOrder({\n            marketID: marketID,\n            subaccountID: subaccountID,\n            feeRecipient: toAsciiString(address(this)),\n            price: 0,\n            quantity: quantity,\n            cid: cid,\n            orderType: \"sell\",\n            triggerPrice: 0\n        });\n        return this.createSpotMarketOrder(order);\n    }\n\n    // ========================================================================\n    // 子账户管理\n    // ========================================================================\n    function generateSubaccountID(uint32 nonce) public view returns (string memory) {\n        string memory nonceHex = toHexString(nonce);\n        while (bytes(nonceHex).length < 24) {\n            nonceHex = string(abi.encodePacked(\"0\", nonceHex));\n        }\n        return string(abi.encodePacked(toAsciiString(address(this)), nonceHex));\n    }\n\n    function getDefaultSubaccountID() public view returns (string memory) {\n        return generateSubaccountID(0);\n    }\n\n    function getSubaccountID(uint32 nonce) public view returns (string memory) {\n        return generateSubaccountID(nonce);\n    }\n\n    function getSubaccountDeposit(\n        string calldata subaccountID,\n        string calldata denom\n    ) external view returns (uint256 availableBalance, uint256 totalBalance) {\n        return exchange.subaccountDeposit(subaccountID, denom);\n    }\n\n    function getSubaccountDeposits(\n        string calldata subaccountID\n    ) external view returns (IExchangeModule.SubaccountDepositData[] memory deposits) {\n        return exchange.subaccountDeposits(subaccountID, toAsciiString(address(this)), 0);\n    }\n\n    function transferBetweenSubaccounts(\n        string calldata sourceSubaccountID,\n        string calldata destinationSubaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external onlyAuthorized returns (bool success) {\n        try exchange.subaccountTransfer(address(this), sourceSubaccountID, destinationSubaccountID, denom, amount) returns (bool result) {\n            return result;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"SubaccountTransfer error: \", reason)));\n        } catch {\n            revert(\"Unknown error during subaccountTransfer\");\n        }\n    }\n\n    function transferToExternalSubaccount(\n        string calldata sourceSubaccountID,\n        string calldata destinationSubaccountID,\n        string calldata denom,\n        uint256 amount\n    ) external onlyAuthorized returns (bool success) {\n        try exchange.externalTransfer(address(this), sourceSubaccountID, destinationSubaccountID, denom, amount) returns (bool result) {\n            return result;\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"ExternalTransfer error: \", reason)));\n        } catch {\n            revert(\"Unknown error during externalTransfer\");\n        }\n    }\n\n    // ========================================================================\n    // 辅助功能\n    // ========================================================================\n    function toAsciiString(address x) internal pure returns (string memory) {\n        bytes memory s = new bytes(40);\n        for (uint i = 0; i < 20; i++) {\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[2*i] = char(hi);\n            s[2*i+1] = char(lo);\n        }\n        return string(s);\n    }\n\n    function toHexString(uint32 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 16;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint8(value & 0xf)));\n            if (uint8(value & 0xf) > 9) {\n                buffer[digits] = bytes1(uint8(87 + uint8(value & 0xf)));\n            }\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n\n    function char(bytes1 b) internal pure returns (bytes1 c) {\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n        else return bytes1(uint8(b) + 0x57);\n    }\n\n    function batchDepositToSubaccounts(\n        uint32[] calldata nonces,\n        string calldata denom,\n        uint256[] calldata amounts\n    ) external onlyAuthorized returns (bool[] memory) {\n        require(nonces.length == amounts.length, \"Array lengths must match\");\n        bool[] memory results = new bool[](nonces.length);\n        for (uint i = 0; i < nonces.length; i++) {\n            string memory subaccountID = generateSubaccountID(nonces[i]);\n            try exchange.deposit(address(this), subaccountID, denom, amounts[i]) returns (bool success) {\n                results[i] = success;\n            } catch {\n                results[i] = false;\n            }\n        }\n        return results;\n    }\n\n    function batchWithdrawFromSubaccounts(\n        uint32[] calldata nonces,\n        string calldata denom,\n        uint256[] calldata amounts\n    ) external onlyAuthorized returns (bool[] memory) {\n        require(nonces.length == amounts.length, \"Array lengths must match\");\n        bool[] memory results = new bool[](nonces.length);\n        for (uint i = 0; i < nonces.length; i++) {\n            string memory subaccountID = generateSubaccountID(nonces[i]);\n            try exchange.withdraw(address(this), subaccountID, denom, amounts[i]) returns (bool success) {\n                results[i] = success;\n            } catch {\n                results[i] = false;\n            }\n        }\n        return results;\n    }\n\n    function getAllSubaccountDeposits(uint32[] calldata nonces) external view returns (IExchangeModule.SubaccountDepositData[][] memory allDeposits) {\n        allDeposits = new IExchangeModule.SubaccountDepositData[][](nonces.length);\n        for (uint i = 0; i < nonces.length; i++) {\n            string memory subaccountID = generateSubaccountID(nonces[i]);\n            allDeposits[i] = exchange.subaccountDeposits(subaccountID, toAsciiString(address(this)), 0);\n        }\n        return allDeposits;\n    }\n\n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function emergencyWithdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}